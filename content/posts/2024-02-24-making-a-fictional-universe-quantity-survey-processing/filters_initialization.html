<script type="text/javascript">

 // parse raw data into objects
 headers = rawData[0];
 fullData = [];

 for (let i = 1; i < rawData.length; i++) {
   let row = rawData[i];
   let obj = {};

   for (let j = 0; j < headers.length; j++) {
     obj[headers[j]] = row[j];
   }

   fullData.push(obj);
 }

 // enrich data

 fullData.forEach(row => {
   const metaGroups = {m_hard: 0,
                       m_core: 0,
                       m_casual: 0};

   for (let filterKey in filters) {
     const filter = filters[filterKey];

     if ('metaGroupPoints' in filter && filter.filter(row)) {
       for (groupKey in filter.metaGroupPoints) {
         if (!(groupKey in metaGroups)) {
           console.log('Unknown group key: ' + groupKey);
         }

         metaGroups[groupKey] += filter.metaGroupPoints[groupKey];
       }
     }

     if (metaGroups.m_core >= metaGroups.m_hard && metaGroups.m_core >= metaGroups.m_casual) {
       row['m_effort'] = 'core';
     } else if (metaGroups.m_casual >= metaGroups.m_hard && metaGroups.m_casual > metaGroups.m_core) {
       row['m_effort'] = 'casual';
     } else if (metaGroups.m_hard > metaGroups.m_core && metaGroups.m_hard > metaGroups.m_casual) {
       row['m_effort'] = 'hard';
     } else {
       console.error('Unknown meta effort group');
     }

     for (let groupKey in metaGroups) {
       row[groupKey] = metaGroups[groupKey];
     }
   }

 });

 // fill filters

 function applyFilters() {
   for (var key in filters) {
     filters[key].values = fullData.filter(filters[key].filter);
   }
 }

 applyFilters();

 function fillFilters() {
   var index = 0;

   var selects = document.querySelectorAll('.plot-filter');

   for (var select of selects) {

     // set id for select
     select.id = 'plot-filter-' + index;
     index++;

     for (var key in filters) {
       var option = document.createElement('option');
       option.value = key;
       option.text = `${filters[key].name} [size: ${filters[key].values.length}]`;
       select.appendChild(option);
     }
   }
 }

 fillFilters();

 function selectFilterA(value, skipEvent) {
   filterA = value;
   var selects = document.querySelectorAll('.plot-filter-a');

   for (var select of selects) {
     select.value = filterA;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function selectFilterB(value, skipEvent) {
   filterB = value;
   var selects = document.querySelectorAll('.plot-filter-b');

   for (var select of selects) {
     select.value = filterB;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function collectQuestionsVariants() {
   const questions = {};

   const rowExample = fullData[0];

   for (let key in rowExample) {
     if (key.includes('#')) {
       const parts = key.split('#');

       if (!(parts[0] in questions)) {
         questions[parts[0]] = {type: 'multichoice',
                                values: []};
       }

       if (!questions[parts[0]].values.includes(parts[1])) {
         questions[parts[0]].values.push(parts[1])
       }
       continue;
     }

     if (key == 'q_age') {
       const values = [];

       ageGroups.forEach(group => {
         values.push(group.id);
       });

       questions[key] = {type: 'age',
                         values: values};
       continue;
     }

     if (key == '') {
       continue;
     }

     if (key == null) {
       continue;
     }

     if (key == 'null') {
       continue;
     }

     if (['q_gender', 'q_occupation', 'q_is_game_developer', 'q_concurrent_agencies', 'q_max_agency_size'].includes(key)) {

       const values = [];

       fullData.forEach(row => {
         if (!values.includes(row[key])) {
           values.push(row[key]);
         }
       });

       questions[key] = {type: 'category',
                         values: values};
       continue;
     }

     questions[key] = {type: 'numeric',
                       values: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]};
   }

   return questions;
 }

 const heatmapQuestions = collectQuestionsVariants();

 function fillHeatmapFilters() {
   var index = 0;

   var selects = document.querySelectorAll('.plot-heatmap-filter');

   for (var select of selects) {

     select.id = 'plot-heatmap-filter-' + index;
     index++;

     for (var key in heatmapQuestions) {
       var option = document.createElement('option');
       option.value = key;
       option.text = key;  // TODO
       select.appendChild(option);
     }
   }
 }

 fillHeatmapFilters();

 function selectHeatmapFilterA(value, skipEvent) {
   heatmapFilterA = value;
   var selects = document.querySelectorAll('.plot-heatmap-filter-a');

   for (var select of selects) {
     select.value = heatmapFilterA;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function selectHeatmapFilterB(value, skipEvent) {
   heatmapFilterB = value;
   var selects = document.querySelectorAll('.plot-heatmap-filter-b');

   for (var select of selects) {
     select.value = heatmapFilterB;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 selectFilterA(filterA, 'skip-event');
 selectFilterB(filterB, 'skip-event');
 selectHeatmapFilterA(heatmapFilterA, 'skip-event');
 selectHeatmapFilterB(heatmapFilterB, 'skip-event');

 document.dispatchEvent(redrawPlots);

 function renderTable(selector, headers, data) {
   const table = document.createElement('table');
   table.style.width = '100%';
   table.setAttribute('border', '1');

   const thead = document.createElement('thead');
   const headerRow = document.createElement('tr');

   headers.forEach(headerText => {
     const header = document.createElement('th');
     header.textContent = headerText;
     headerRow.appendChild(header);
   });

   thead.appendChild(headerRow);

   table.appendChild(thead);

   const tbody = document.createElement('tbody');

   data.forEach(row => {
     const tr = document.createElement('tr');
     row.forEach((cell, index) => {
       const td = document.createElement('td');
       if (Array.isArray(cell)) {
         td.innerHTML = cell.join('<br>');
       } else {
         td.textContent = cell;
       }
       tr.appendChild(td);
     });
     tbody.appendChild(tr);
   });
   table.appendChild(tbody);

   const container = document.querySelector(selector);
   container.innerHTML = '';
   container.appendChild(table);
 }

 function tableFinalGroups(selector) {
   const dimensions = [['hard', 'core', 'casual'],
                       ['agencySizeRelativlySmall', 'agencySizeRelativlyBig'],
                       ['competitorsFew', 'competitorsAlot']];

   const groups = {};

   // initialize storage

   for (let effort of dimensions[0]) {
     for (let agencySize of dimensions[1]) {
       for (let competitors of dimensions[2]) {
         groups[`${effort}-${agencySize}-${competitors}`] = {
           total: 0,
           dimensions: {
             effort: effort,
             agencySize: agencySize,
             competitors: competitors
           },
           plotStyle: {},
           worldStyle: {}
         }
       }
     }
   }

   // collect statistics
   fullData.forEach(row => {
     const key = [];

     for (let dimension of dimensions) {
       for (let filterKey of dimension) {
         if (filters[filterKey].filter(row)) {
           key.push(filterKey);
           break;
         }
       }
     }

     const groupKey = key.join('-');

     if (!(groupKey in groups)) {
       return;
     }

     groups[groupKey].total += 1;

     for (let key in row) {

       if (row[key] != 1) {
         continue;
       }

       if (!key.includes('#')) {
         continue;
       }

       const parts = key.split('#');

       const question = parts[0];
       const value = parts[1];

       const group = groups[groupKey];

       if (question == 'q_plot_style') {
         if (!(value in group.plotStyle)) {
           group.plotStyle[value] = 0;
         }
         group.plotStyle[value] += 1;
       }

       if (question == 'q_world_style') {
         if (!(value in group.worldStyle)) {
           group.worldStyle[value] = 0;
         }
         group.worldStyle[value] += 1;
       }
     }

     groups[groupKey].plotStyle
   });

   // format data

   const table = [];

   const rowIndex = 0;

   function selectTopN(styles, n) {
      const sorted = Object.keys(styles).sort((a, b) => styles[b] - styles[a]);

      const result = [];

      for (let i = 0; i < n; i++) {
        if (i >= sorted.length) {
          break;
        }

        result.push(`${sorted[i]}: ${styles[sorted[i]]}`);
      }

      return result;
   }

   const n = 5;

   for (let effort of dimensions[0]) {
     for (let agencySize of dimensions[1]) {
       for (let competitors of dimensions[2]) {
         const groupKey = `${effort}-${agencySize}-${competitors}`;
         const group = groups[groupKey];

         table.push([effort,
                     agencySize,
                     competitors,
                     group.total,
                     selectTopN(group.worldStyle, n),
                     selectTopN(group.plotStyle, n)]);
       }
     }
   }

   function transpose(array) {
     // Check if the input array is empty
     if(array.length === 0) {
       return [];
     }

     // Transpose the array
     return array[0].map((_, colIndex) => array.map(row => row[colIndex]));
   }

   renderTable(selector,
               ['effort', 'agency size', 'competitors', 'size', 'world style', 'plot style'],
               table);
 }

 /* TODO: move into the main file? */
 tableFinalGroups('#table-final-groups');

</script>
