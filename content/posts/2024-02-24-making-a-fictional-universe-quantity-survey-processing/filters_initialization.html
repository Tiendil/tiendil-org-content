<script type="text/javascript">

 // parse raw data into objects
 headers = rawData[0];
 fullData = [];

 for (let i = 1; i < rawData.length; i++) {
   let row = rawData[i];
   let obj = {};

   for (let j = 0; j < headers.length; j++) {
     obj[headers[j]] = row[j];
   }

   fullData.push(obj);
 }

 // enrich data

 fullData.forEach(row => {
   const metaGroups = {m_hard: 0,
                       m_core: 0,
                       m_casual: 0};

   for (let filterKey in filters) {
     const filter = filters[filterKey];

     if ('metaGroupPoints' in filter && filter.filter(row)) {
       for (groupKey in filter.metaGroupPoints) {
         if (!(groupKey in metaGroups)) {
           console.log('Unknown group key: ' + groupKey);
         }

         metaGroups[groupKey] += filter.metaGroupPoints[groupKey];
       }
     }

     if (metaGroups.m_core >= metaGroups.m_hard && metaGroups.m_core >= metaGroups.m_casual) {
       row['m_effort'] = 'core';
     } else if (metaGroups.m_casual >= metaGroups.m_hard && metaGroups.m_casual > metaGroups.m_core) {
       row['m_effort'] = 'casual';
     } else if (metaGroups.m_hard > metaGroups.m_core && metaGroups.m_hard > metaGroups.m_casual) {
       row['m_effort'] = 'hard';
     } else {
       console.error('Unknown meta effort group');
     }

     for (let groupKey in metaGroups) {
       row[groupKey] = metaGroups[groupKey];
     }
   }

 });

 // fill filters

 function applyFilters() {
   for (var key in filters) {
     filters[key].values = fullData.filter(filters[key].filter);
   }
 }

 applyFilters();

 function fillFilters() {
   var index = 0;

   var selects = document.querySelectorAll('.plot-filter');

   for (var select of selects) {

     // set id for select
     select.id = 'plot-filter-' + index;
     index++;

     for (var key in filters) {
       var option = document.createElement('option');
       option.value = key;
       option.text = `${filters[key].name} [size: ${filters[key].values.length}]`;
       select.appendChild(option);
     }
   }
 }

 fillFilters();

 function selectFilterA(value, skipEvent) {
   filterA = value;
   var selects = document.querySelectorAll('.plot-filter-a');

   for (var select of selects) {
     select.value = filterA;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function selectFilterB(value, skipEvent) {
   filterB = value;
   var selects = document.querySelectorAll('.plot-filter-b');

   for (var select of selects) {
     select.value = filterB;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function collectQuestionsVariants() {
   const questions = {};

   const rowExample = fullData[0];

   for (let key in rowExample) {
     if (key.includes('#')) {
       const parts = key.split('#');

       if (!(parts[0] in questions)) {
         questions[parts[0]] = {type: 'multichoice',
                                values: []};
       }

       if (!questions[parts[0]].values.includes(parts[1])) {
         questions[parts[0]].values.push(parts[1])
       }
       continue;
     }

     if (key == 'q_age') {
       const values = [];

       ageGroups.forEach(group => {
         values.push(group.id);
       });

       questions[key] = {type: 'age',
                         values: values};
       continue;
     }

     if (key == '') {
       continue;
     }

     if (key == null) {
       continue;
     }

     if (key == 'null') {
       continue;
     }

     if (['q_gender', 'q_occupation', 'q_is_game_developer', 'q_concurrent_agencies', 'q_max_agency_size'].includes(key)) {

       const values = [];

       fullData.forEach(row => {
         if (!values.includes(row[key])) {
           values.push(row[key]);
         }
       });

       questions[key] = {type: 'category',
                         values: values};
       continue;
     }

     questions[key] = {type: 'numeric',
                       values: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]};
   }

   return questions;
 }

 const heatmapQuestions = collectQuestionsVariants();

 function fillHeatmapFilters() {
   var index = 0;

   var selects = document.querySelectorAll('.plot-heatmap-filter');

   for (var select of selects) {

     select.id = 'plot-heatmap-filter-' + index;
     index++;

     for (var key in heatmapQuestions) {
       var option = document.createElement('option');
       option.value = key;
       option.text = key;  // TODO
       select.appendChild(option);
     }
   }
 }

 fillHeatmapFilters();

 function selectHeatmapFilterA(value, skipEvent) {
   heatmapFilterA = value;
   var selects = document.querySelectorAll('.plot-heatmap-filter-a');

   for (var select of selects) {
     select.value = heatmapFilterA;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 function selectHeatmapFilterB(value, skipEvent) {
   heatmapFilterB = value;
   var selects = document.querySelectorAll('.plot-heatmap-filter-b');

   for (var select of selects) {
     select.value = heatmapFilterB;
   }

   if (skipEvent != 'skip-event') {
     document.dispatchEvent(redrawPlots);
   }
 }

 selectFilterA(filterA, 'skip-event');
 selectFilterB(filterB, 'skip-event');
 selectHeatmapFilterA(heatmapFilterA, 'skip-event');
 selectHeatmapFilterB(heatmapFilterB, 'skip-event');

 document.dispatchEvent(redrawPlots);

 function renderTable(selector, headers, data) {
   const table = document.createElement('table');
   table.style.width = '100%';
   table.setAttribute('border', '1');

   const thead = document.createElement('thead');
   const headerRow = document.createElement('tr');

   headers.forEach(headerText => {
     const header = document.createElement('th');
     header.textContent = headerText;
     headerRow.appendChild(header);
   });

   thead.appendChild(headerRow);

   table.appendChild(thead);

   const tbody = document.createElement('tbody');

   data.forEach(row => {
     const tr = document.createElement('tr');
     row.forEach((cell, index) => {
       const td = document.createElement('td');
       if (Array.isArray(cell)) {
         td.innerHTML = cell.join('<br>');
       } else {
         td.textContent = cell;
       }
       tr.appendChild(td);
     });
     tbody.appendChild(tr);
   });
   table.appendChild(tbody);

   const container = document.querySelector(selector);
   container.innerHTML = '';
   container.appendChild(table);
 }

 /* Unity with heuristics
    - we do not interested in casual players, because they are smallest group and generally do not part of the core community
    - we targe core audience (it is the biggest) and try to take hardcore players as well (they are bigger than casual and often make a core of the community) => it is a good idea to unite core & hard groups with the same mechanics
    - => we unite "hard+small+few" and "core+small+few". They are biggest groyps in hard and core categories, have common preferences
    - => second polus is "hard+big+alot" and "core+big+alot". They have good correlation on mechanics, but not ideal correlation on the world style and plot style. But I think it is artifact of the small sample size.
  */
 const finalGroups = [{name: '(core|hard)+small+few',
                       filters: [['hard', 'agencySizeRelativlySmall', 'competitorsFew'],
                                 ['core', 'agencySizeRelativlySmall', 'competitorsFew']]},
                      {name: 'hard+small+alot',
                       filters: [['hard', 'agencySizeRelativlySmall', 'competitorsAlot']]},
                      {name: 'hard+big+few',
                       filters: [['hard', 'agencySizeRelativlyBig', 'competitorsFew']]},
                      {name: '(core|hard)+big+alot',
                       filters: [['hard', 'agencySizeRelativlyBig', 'competitorsAlot'],
                                 ['core', 'agencySizeRelativlyBig', 'competitorsAlot']]},
                      {name: 'core+small+alot',
                       filters: [['core', 'agencySizeRelativlySmall', 'competitorsAlot']]},
                      {name: 'core+big+few',
                       filters: [['core', 'agencySizeRelativlyBig', 'competitorsFew']]}];

 function isFinalGroupSuitable(group, row) {
   for (let filtersSet of group.filters) {
     let found = true;

     for (let filterKey of filtersSet) {
       if (!filters[filterKey].filter(row)) {
         found = false;
         break;
       }
     }

     if (found) {
       return true;
     }
   }

   return false;
 }

 function tableFinalGroups(selector) {

   for (let group of finalGroups) {
     group.total = 0;
     group.plotStyle = {};
     group.worldStyle = {};
     group.likeInGames = {};
   }

   // collect statistics
   fullData.forEach(row => {
     const key = [];

     const foundGroups = [];

     for (let group of finalGroups) {
       if (!isFinalGroupSuitable(group, row)) {
         continue;
       }

       foundGroups.push(group);
     }

     if (foundGroups.length == 0) {
       /* console.log(foundGroups.length, row['m_effort'], row['q_max_agency_size'], row['q_concurrent_agencies']);
        * console.error('There should be exactly one suitable group'); */
       return;
     }

     for (let group of foundGroups) {

       group.total += 1;

       for (let key in row) {

         if (row[key] != 1) {
           continue;
         }

         if (!key.includes('#')) {
           continue;
         }

         const parts = key.split('#');

         const question = parts[0];
         const value = parts[1];

         /* if (value == null || value == 'null' || value == '') {
          *   continue;
          * } */

         if (question == 'q_plot_style') {
           if (!(value in group.plotStyle)) {
             group.plotStyle[value] = 0;
           }
           group.plotStyle[value] += 1;
         }

         if (question == 'q_world_style') {
           if (!(value in group.worldStyle)) {
             group.worldStyle[value] = 0;
           }
           group.worldStyle[value] += 1;
         }

         if (question == 'q_like_in_games') {
           if (!(value in group.likeInGames)) {
             group.likeInGames[value] = 0;
           }
           group.likeInGames[value] += 1;
         }
       }
     }
   });

   // format data

   const table = [];

   const rowIndex = 0;

   function selectTopN(styles, n) {
      const sorted = Object.keys(styles).sort((a, b) => styles[b] - styles[a]);

      const result = [];

      for (let i = 0; i < n; i++) {
        if (i >= sorted.length) {
          break;
        }

        result.push(`${sorted[i]}: ${styles[sorted[i]]}`);
      }

      return result;
   }

   const n = 7;

   for (let group of finalGroups) {
     table.push([group.name,
                 group.total,
                 selectTopN(group.likeInGames, n),
                 selectTopN(group.worldStyle, n),
                 selectTopN(group.plotStyle, n)]);
   }

   function transpose(array) {
     // Check if the input array is empty
     if(array.length === 0) {
       return [];
     }

     // Transpose the array
     return array[0].map((_, colIndex) => array.map(row => row[colIndex]));
   }

   renderTable(selector,
               ['name', 'size', 'like in games', 'world style', 'plot style'],
               table);
 }

 /* TODO: move into the main file? */
 tableFinalGroups('#table-final-groups');

</script>
