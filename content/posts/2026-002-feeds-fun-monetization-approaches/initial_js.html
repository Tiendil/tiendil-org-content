<!-- TODO: move to brigid config? -->
<!-- TODO: if moved, how to turn on optionally? -->

<script src="https://cdn.plot.ly/plotly-2.29.1.min.js" charset="utf-8"></script>


<script type="text/javascript">

const redrawPlots = new CustomEvent('redrawPlots', {
    detail: {
        message: "redraw plots",
    }
 });


const marginLevels = [
    {id: 'x2', name: 'x2', value: 2},
    {id: 'x3', name: 'x3', value: 3},
    {id: 'x5', name: 'x5', value: 5},
    {id: 'x10', name: 'x10', value: 10},
    {id: 'x20', name: 'x20', value: 20},
];

const discountLevels = [
    {id: 'd05', name: '5%', value: 0.05},
    {id: 'd10', name: '10%', value: 0.10},
    {id: 'd15', name: '15%', value: 0.15},
    {id: 'd20', name: '20%', value: 0.20},
];

var filterBaseMargin = 'x2';
var filterDiscountStep = 'd10';

const subscribersNumber = 1000;
const daysInMonth = 30;
const discountStep = 0.1;

const modelConfig = window.modelConfig = {
    cogsPerNews: 0.0006865,
    serverCost: 75,
    customerAcquisitionCost: 50,
    cancellationRate: 0.05,
    baseSubscriptionQuota: 250,
    professionalSubscriptionQuota: 1000,
    audience: {
        beginners: {fraction: 0.8, minNews: 1, maxNews: 99},
        advanced: {fraction: 0.16, minNews: 100, maxNews: 999}
    }
};

const paymentProcessorCommissionPercent = 0.025; // Stripe fee
const paymentProcessorCommissionFixed = 0.25;  // Stripe fee

function formatMoneyK(value) {
    if (value == null || Number.isNaN(value)) {
        return 'N/A';
    }
    if (Math.abs(value) < 1000) {
        return value.toFixed(2);
    }
    return (value / 1000).toFixed(2) + 'k';
}

function formatMoneyToken(value) {
    if (value == null || Number.isNaN(value)) {
        return 'N/A';
    }
    return (value * 100).toFixed(2);
}

function formatMonthlyDaily(value) {
    if (value == null || Number.isNaN(value)) {
        return 'N/A';
    }
    var perDay = value / daysInMonth;
    return `${formatMoneyK(value)} $/m / ${formatMoneyK(perDay)} $/d`;
}

function formatMonthlyOnly(value) {
    if (value == null || Number.isNaN(value)) {
        return 'N/A';
    }
    return `${formatMoneyK(value)} $/m`;
}

function consumptionPrice(tokens, subQuota, subTokenPrice, extraTokenPrice) {
    const subPrice = subQuota * subTokenPrice;

    if (tokens <= subQuota) {
        return subPrice;
    }

    return subPrice + (tokens - subQuota) * extraTokenPrice;
}
function baseSubTokenPrice(N) {
    return modelConfig.cogsPerNews * N;
}

function baseExtraTokenPrice(N, step) {
    return modelConfig.cogsPerNews * N * (1 - 1 * step);
}

function profSubTokenPrice(N, step) {
    return modelConfig.cogsPerNews * N * (1 - 2 * step);
}

function profExtraTokenPrice(N, step) {
    return modelConfig.cogsPerNews * N * (1 - 3 * step);
}

function basePricePerDay(tokens, N, step) {
    return consumptionPrice(tokens,
                            modelConfig.baseSubscriptionQuota,
                            baseSubTokenPrice(N),
                            baseExtraTokenPrice(N, step));
}

function profPricePerDay(tokens, N, step) {
    return consumptionPrice(tokens,
                            modelConfig.professionalSubscriptionQuota,
                            profSubTokenPrice(N, step),
                            profExtraTokenPrice(N, step));
}

function paidInMonth(tokensPerDay, N, step) {
    const paidInDay = Math.min(basePricePerDay(tokensPerDay, N, step),
                               profPricePerDay(tokensPerDay, N, step));
    return paidInDay * daysInMonth;
}

function spentInMonth(tokensPerDay) {
    return tokensPerDay * modelConfig.cogsPerNews * daysInMonth;
}

let users = [];

function buildAudienceConfig() {
    var beginnerFraction = modelConfig.audience.beginners.fraction;
    var advancedFraction = modelConfig.audience.advanced.fraction;
    var professionalFraction = Math.max(0, 1 - beginnerFraction - advancedFraction);
    var professionalMin = modelConfig.audience.advanced.maxNews + 1;

    return [
        {
            name: 'beginner',
            fraction: beginnerFraction,
            minNews: modelConfig.audience.beginners.minNews,
            maxNews: modelConfig.audience.beginners.maxNews
        },
        {
            name: 'advanced',
            fraction: advancedFraction,
            minNews: modelConfig.audience.beginners.maxNews + 1,
            maxNews: modelConfig.audience.advanced.maxNews
        },
        {
            name: 'professional',
            fraction: professionalFraction,
            minNews: professionalMin,
            maxNews: professionalMin
        }
    ];
}

function rebuildUsers() {
    users = [];
    var audienceConfig = buildAudienceConfig();

    for (let i = 0; i < audienceConfig.length; i++) {
        const group = audienceConfig[i];
        const groupSize = Math.ceil(subscribersNumber * group.fraction);

        const {min, max} = {min: group.minNews, max: group.maxNews};

        for (let j = 0; j < groupSize; j++) {
            // deterministic quantile in (0, 1)
            const v = (j + 0.5) / groupSize;

            // log-uniform quantile: n = min * (max/min)^v
            const n = (min === max)
                ? min
                  : Math.round(min * Math.pow(max / min, v));

            const newsPerDay = Math.max(min, Math.min(max, n));

            users.push({
                newsPerDay: newsPerDay,
                groupId: i,
            });
        }
    }
}

function COGSGlobal() {
    return modelConfig.serverCost +
        (Math.ceil(subscribersNumber * modelConfig.cancellationRate) * modelConfig.customerAcquisitionCost);
}

function PaymentProcessorFee(amount) {
    return amount * paymentProcessorCommissionPercent + paymentProcessorCommissionFixed * subscribersNumber;
}

function model(costMultipler, discountStep) {

    let paidTotal = 0;
    let spentTotal = 0;

    for (let i = 0; i < users.length; i++) {
        const user = users[i];

        const paid = paidInMonth(user.newsPerDay,
                                 costMultipler,
                                 discountStep);

        const spent = spentInMonth(user.newsPerDay);

        paidTotal += paid;
        spentTotal += spent;
    }

    const paymentProcessorFee = PaymentProcessorFee(paidTotal);

    return {
        costMultipler: costMultipler,
        discountStep: discountStep,
        totalPaid: paidTotal,

        spentOnNews: spentTotal,
        paymentProcessorFee: paymentProcessorFee,

        grossMargin: paidTotal - spentTotal - COGSGlobal() - paymentProcessorFee
    };

}

let fullData = [];

function rebuildModelData() {
    rebuildUsers();
    fullData = [];

    for (let subMarginLevel of marginLevels) {
        for (let discountLevel of discountLevels) {
            fullData.push(model(subMarginLevel.value, discountLevel.value));
        }
    }

    document.dispatchEvent(redrawPlots);
}

window.rebuildModelData = rebuildModelData;
rebuildModelData();

function createPlotlyConfig(filename) {
    var config = {
        toImageButtonOptions: {
            format: 'png', // one of png, svg, jpeg, webp
            filename: filename,
            scale: 1
        },
        modeBarButtonsToRemove: [
            'zoom2d', 'pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d',
            'zoom3d', 'pan3d', 'orbitRotation', 'tableRotation', 'handleDrag3d',
            'resetCameraDefault3d', 'resetCameraLastSave3d', 'hoverClosest3d',
            'hoverClosestCartesian', 'hoverCompareCartesian',
            'zoomInGeo', 'zoomOutGeo', 'resetGeo', 'hoverClosestGeo',
            'hoverClosestGl2d', 'hoverClosestPie', 'toggleHover', 'resetViews', 'sendDataToCloud', 'toggleSpikelines', 'resetViewMapbox'
        ]
    };

    return config;
}

function updateSummaryTable() {
    var table = document.querySelector('.plot-summary-table');
    if (!table) {
        return;
    }

    var marginLevel = marginLevels.find(level => level.id === filterBaseMargin) || marginLevels[0];
    var marginMultiplier = marginLevel ? marginLevel.value : marginLevels[0].value;
    var discountLevel = discountLevels.find(level => level.id === filterDiscountStep) || discountLevels[0];
    var discountValue = discountLevel ? discountLevel.value : discountLevels[0].value;

    var basicSubMonthly = modelConfig.baseSubscriptionQuota *
        baseSubTokenPrice(marginMultiplier) *
        daysInMonth;
    var basicTokenPrice = baseExtraTokenPrice(marginMultiplier, discountValue);

    var profSubMonthly = modelConfig.professionalSubscriptionQuota *
        profSubTokenPrice(marginMultiplier, discountValue) *
        daysInMonth;
    var profTokenPrice = profExtraTokenPrice(marginMultiplier, discountValue);

    var baseRevenue = 0;
    var profRevenue = 0;
    var groupProfits = new Array(buildAudienceConfig().length).fill(0);
    var summaryModel = model(marginMultiplier, discountValue);

    var globalCostPerUser = COGSGlobal() / subscribersNumber;

    for (let i = 0; i < users.length; i++) {
        var user = users[i];
        var basePaidMonthly = basePricePerDay(user.newsPerDay, marginMultiplier, discountValue) * daysInMonth;
        var profPaidMonthly = profPricePerDay(user.newsPerDay, marginMultiplier, discountValue) * daysInMonth;
        var paidMonthly = Math.min(basePaidMonthly, profPaidMonthly);

        if (basePaidMonthly <= profPaidMonthly) {
            baseRevenue += paidMonthly;
        } else {
            profRevenue += paidMonthly;
        }

        var spentMonthly = spentInMonth(user.newsPerDay);
        var paymentFee = paidMonthly * paymentProcessorCommissionPercent + paymentProcessorCommissionFixed;
        var profitMonthly = paidMonthly - spentMonthly - paymentFee - globalCostPerUser;

        if (user.groupId != null && groupProfits[user.groupId] != null) {
            groupProfits[user.groupId] += profitMonthly;
        }
    }

    function applyValueClass(cell, numericValue) {
        cell.classList.remove('value-negative', 'value-warn', 'value-good');

        if (numericValue == null || Number.isNaN(numericValue)) {
            return;
        }

        if (numericValue < 0) {
            cell.classList.add('value-negative');
        } else if (numericValue > 20000) {
            cell.classList.add('value-good');
        } else if (numericValue > 10000) {
            cell.classList.add('value-warn');
        }
    }

    function setSummaryValue(key, value, numericValue) {
        var cell = table.querySelector(`[data-summary="${key}"]`);
        if (!cell) {
            return;
        }
        cell.textContent = value;
        applyValueClass(cell, numericValue);
    }

    setSummaryValue('basicSubscriptionPrice', formatMonthlyOnly(basicSubMonthly), basicSubMonthly);
    setSummaryValue('basicTokenPrice', `${formatMoneyToken(basicTokenPrice)} $/100 news`, null);
    setSummaryValue('professionalSubscriptionPrice', formatMonthlyOnly(profSubMonthly), profSubMonthly);
    setSummaryValue('professionalTokenPrice', `${formatMoneyToken(profTokenPrice)} $/100 news`, null);
    setSummaryValue('basicRevenue', formatMonthlyOnly(baseRevenue), baseRevenue);
    setSummaryValue('professionalRevenue', formatMonthlyOnly(profRevenue), profRevenue);
    setSummaryValue('beginnerProfit', formatMonthlyOnly(groupProfits[0]), groupProfits[0]);
    setSummaryValue('advancedProfit', formatMonthlyOnly(groupProfits[1]), groupProfits[1]);
    setSummaryValue('professionalProfit', formatMonthlyOnly(groupProfits[2]), groupProfits[2]);
    setSummaryValue('grossMargin', formatMonthlyOnly(summaryModel.grossMargin), summaryModel.grossMargin);
}

function heatmapPlot(selector, kind) {
    document.addEventListener('redrawPlots', (e) => {

        if (fullData === null) {
            return;
        }

        const metric = kind || 'grossMargin';
        const metricLabels = {
            grossMargin: 'Gross Margin, $',
            totalPaid: 'Total Paid, $',
            spentOnNews: 'Spent on News, $',
            paymentProcessorFee: 'Payment Processor Fee, $'
        };

        const dataByKey = new Map();

        function keyFor(marginValue, discountValue) {
            return `${marginValue}|${discountValue.toFixed(4)}`;
        }

        for (let row of fullData) {
            dataByKey.set(keyFor(row.costMultipler, row.discountStep), row);
        }

        const z = [];
        const text = [];

        for (let discount of discountLevels) {
            const row = [];
            const textRow = [];

            for (let margin of marginLevels) {
                const rowData = dataByKey.get(keyFor(margin.value, discount.value));
                const metricValue = rowData ? rowData[metric] : null;

                row.push(metricValue);
                textRow.push(
                    rowData
                        ? `Gross Margin: ${formatMonthlyDaily(rowData.grossMargin)}<br>` +
                          `Total Paid: ${formatMonthlyDaily(rowData.totalPaid)}<br>` +
                          `Spent on News: ${formatMonthlyDaily(rowData.spentOnNews)}<br>` +
                          `Payment Fees: ${formatMonthlyDaily(rowData.paymentProcessorFee)}`
                        : 'N/A'
                );
            }

            z.push(row);
            text.push(textRow);
        }

        var data = [
            {
                z: z,
                x: marginLevels.map(level => level.name),
                y: discountLevels.map(level => level.name),
                text: text,
                type: 'heatmap',
                hoverinfo: 'text',
                colorbar: {
                    title: metricLabels[metric] || metric
                }
            }
        ];

        var layout = {
            barmode: 'group',
            xaxis: {
                title: 'Margin multiplier'
            },
            yaxis: {
                title: 'Discount'
            }
        };

        var config = createPlotlyConfig(`${selector}-${metric}`);

        Plotly.react(selector, data, layout, config);
    });
}

document.addEventListener('redrawPlots', updateSummaryTable);

function updateAudienceSummary() {
    var beginnerFraction = modelConfig.audience.beginners.fraction;
    var advancedFraction = modelConfig.audience.advanced.fraction;
    var professionalFraction = Math.max(0, 1 - beginnerFraction - advancedFraction);

    var advancedMin = modelConfig.audience.beginners.maxNews + 1;
    var professionalMin = modelConfig.audience.advanced.maxNews + 1;
    var professionalMax = 'inf';

    function setSummary(key, value) {
        var cell = document.querySelector(`[data-audience-summary="${key}"]`);
        if (!cell) {
            return;
        }
        cell.textContent = value;
    }

    setSummary('professionalFraction', professionalFraction.toFixed(2));
    setSummary('advancedMin', advancedMin);
    setSummary('professionalMin', professionalMin);
    setSummary('professionalMax', professionalMax);
}

document.addEventListener('redrawPlots', updateAudienceSummary);

// function filterRows(subMarginId, tokenMarginId) {
//     const subMarginValue = marginLevels.find(level => level.id === subMarginId).value;
//     const tokenMarginValue = marginLevels.find(level => level.id === tokenMarginId).value;

//     return fullData.filter(function(row) {
//         return row.subMarginX === subMarginValue &&
//                row.tokenMarginX === tokenMarginValue;
//     });
// }

// function barPlot(selector, map, barsOrder) {

//     document.addEventListener('redrawPlots', (e) => {

//         const dataARows = filterRows(filterASubMargin, filterATokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);
//         const dataBRows = filterRows(filterBSubMargin, filterBTokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);

//         // function toText(percents, counts) {
//         //     return percents.map((x, i) => x.toString() + ' ' + T('% count:') + ' ' + counts[i].toString());
//         // }

//         function barData(name, dataRows) {
//             return {
//                 x: dataRows.map(row => `${row.model}`),
//                 y: dataRows.map(row => row.grossMargin.toFixed(2)),
//                 text: dataRows.map(row => row.grossMargin.toFixed(2)),
//                 'textposition': "none",
//                 'hoverinfo': 'text',
//                 'name': name,
//                 'type': 'bar'
//             };
//         }

//         var data = [
//             barData("approach 1", dataARows),
//             barData("approach 2", dataBRows)
//         ];

//         var layout = {
//             barmode: 'group',
//             xaxis: {
//                 dtick: 1
//             },
//             yaxis: {
//                 title: 'Gross Margin, $',
//             },
//             legend: {
//                 orientation: 'h',
//                 x: 0.5, // Centers the legend horizontally
//                 xanchor: 'center', // Uses the center of the legend as the anchor point
//                 y: 1.1, // Positions the legend above the chart
//                 yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
//             }
//         };

//         // TODO: better unique name
//         var config = createPlotlyConfig('${filterASubMargin}-${filterATokenMargin}-${filterBSubMargin}-${filterBTokenMargin}');

//         Plotly.react(selector, data, layout, config);
//     });
// }

// function scatterpolarPlot(selector, mode) {
//     document.addEventListener('redrawPlots', (e) => {

//         if (fullData === null) {
//             return;
//         }

//         if (!(filterA in filters)) {
//             console.error('Unknown filterA:', filterA);
//             return;
//         }

//         if (!(filterB in filters)) {
//             console.error('Unknown filterB:', filterA);
//             return;
//         }

//         const dataA = filters[filterA].values;
//         const dataB = filters[filterB].values;

//         const theta = ['q_age',
//                        'q_play_strategy_games',
//                        'q_playing_effort',
//                        'q_playing_effort',
//                        'q_multiple_channels_esential',
//                        'q_realistic_work',
//                        'q_budget_effort',
//                        'q_office_effort',
//                        'q_morale_complexity',
//                        'q_relationships_effort'];


//         const translatedTheta = theta.map(T);

//         function values(data, column) {
//             return data.map(row => row[column]);
//         }

//         function fullValues(column) {
//             return fullData.map(row => row[column]);
//         }

//         function dimensionMedian(data, column) {
//             // r should containt median for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//                 var thetaValues = values(data, theta[i]);

//                 // we should nor to the maximum from all data, not from current data
//                 const max = Math.max(...fullValues(theta[i]));

//                 thetaValues = thetaValues.map(x => x / max);
//                 thetaValues.sort((a, b) => a - b);
//                 r.push(thetaValues[Math.floor(thetaValues.length / 2)]);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         function dimensionAverage(data, column) {
//             // r should containt average for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//               var thetaValues = values(data, theta[i]);

//               // we should nor to the maximum from all data, not from current data
//               const max = Math.max(...fullValues(theta[i]));

//               thetaValues = thetaValues.map(x => x / max);
//               r.push(thetaValues.reduce((a, b) => a + b, 0) / thetaValues.length);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         var dimension = null;

//         if (mode === 'median') {
//             dimension = dimensionMedian;
//         } else {
//             dimension = dimensionAverage;
//         }

//         var data = [
//             dimension(dataA, filters[filterA].name),
//             dimension(dataB, filters[filterB].name)
//         ];

//         var layout = {
//             barmode: 'group',
//             xaxis: {
//                 dtick: 1
//             },
//             yaxis: {
//                 dtick: 1
//             },
//             legend: {
//                 orientation: 'h',
//                 x: 0.5, // Centers the legend horizontally
//                 xanchor: 'center', // Uses the center of the legend as the anchor point
//                 y: 1.1, // Positions the legend above the chart
//                 yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
//             }
//         };

//         var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

//         Plotly.react(selector, data, layout, config);
//     });

// }



</script>
