<!-- TODO: move to brigid config? -->
<!-- TODO: if moved, how to turn on optionally? -->

<script src="https://cdn.plot.ly/plotly-2.29.1.min.js" charset="utf-8"></script>


<script type="text/javascript">

const redrawPlots = new CustomEvent('redrawPlots', {
    detail: {
        message: "redraw plots",
    }
 });

function T(text) {
   if (!(text in translations)) {
       console.error('Unknown translation:', text);
     return text;
   }

   return translations[text];
}

const subscribersNumber = [{id: 'subscribers_100',
                           name: '100 Subscribers',
                           addToFilter: true},
                           {id: 'subscribers_1000',
                           name: '1000 Subscribers',
                           addToFilter: true},
                           {id: 'subscribers_10000',
                           name: '10000 Subscribers',
                           addToFilter: true}];

 // translate filters
 // for (let filterId in filters) {
 //   let filter = filters[filterId];
 //   filter.name = T(filter.name);
 // }

var fullData = null;

var filterA = 'all';
var filterB = 'adults (30-39)';

var heatmapFilterA = 'q_world_style';
var heatmapFilterB = 'q_plot_style';

function groupMapper(groups) {
    return function(row) {
        const resultGroups = [];

        for (let groupIndex in groups) {
            const group = groups[groupIndex];

            if (group.predicate(row)) {
                resultGroups.push(group.id);
            }
        }

        return resultGroups;
    };
}

function groupIds(groups) {
    return groups.map(function(group) {
        return group.id;
    });
}

function getPlotData(filteredData, map, uniqueValues) {
    var mappedData = filteredData.map(map);

    // if mappedData contains multiple groups per row, flatten it
    if (mappedData[0] instanceof Array) {
        mappedData = mappedData.flat();
    }

    // print error if mappedData contains item not from uniqueValues
    mappedData.forEach(function(value) {
        if (!uniqueValues.includes(value)) {
          console.log('Value ' + value + ' not in uniqueValues');
        }
    });

    const counts = uniqueValues.map(function(value) {
        return mappedData.filter(function(x) {
            return x === value;
        }).length;
    });


    const percents = counts.map(function(count) {
        return (count / filteredData.length * 100).toFixed(2);
    });

    return {
        values: uniqueValues,
        counts: counts,
        percents: percents
    };
}

function createPlotlyConfig(filename) {
    var config = {
        toImageButtonOptions: {
            format: 'png', // one of png, svg, jpeg, webp
            filename: filename,
            scale: 1
        },
        modeBarButtonsToRemove: [
            'zoom2d', 'pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d',
            'zoom3d', 'pan3d', 'orbitRotation', 'tableRotation', 'handleDrag3d',
            'resetCameraDefault3d', 'resetCameraLastSave3d', 'hoverClosest3d',
            'hoverClosestCartesian', 'hoverCompareCartesian',
            'zoomInGeo', 'zoomOutGeo', 'resetGeo', 'hoverClosestGeo',
            'hoverClosestGl2d', 'hoverClosestPie', 'toggleHover', 'resetViews', 'sendDataToCloud', 'toggleSpikelines', 'resetViewMapbox'
        ]
    }
}

function barPlot(selector, map, barsOrder) {

    document.addEventListener('redrawPlots', (e) => {

        if (fullData === null) {
            return;
        }

        if (!(filterA in filters)) {
            console.log('Unknown filterA:', filterA);
            return;
        }

        if (!(filterB in filters)) {
            console.log('Unknown filterB:', filterA);
            return;
        }

        const dataA = getPlotData(filters[filterA].values, map, barsOrder);
        const dataB = getPlotData(filters[filterB].values, map, barsOrder);

        function toText(percents, counts) {
            return percents.map((x, i) => x.toString() + ' ' + T('% count:') + ' ' + counts[i].toString());
        }

        data = [{
            'x': dataA.values.map(T),
            'y': dataA.percents,
            'textposition': "none",
            'text': toText(dataA.percents, dataA.counts),
            'hoverinfo': 'text',
            'name': filters[filterA].name,
            'type': 'bar'
        },{
            'x': dataB.values.map(T),
            'y': dataB.percents,
            'textposition': "none",
            'text': toText(dataB.percents, dataB.counts),
            'hoverinfo': 'text',
            'name': filters[filterB].name,
            'type': 'bar'
        }];

        var layout = {
            barmode: 'group',
            xaxis: {
                dtick: 1
            },
            yaxis: {
                title: T('percents')
            },
            legend: {
                orientation: 'h',
                x: 0.5, // Centers the legend horizontally
                xanchor: 'center', // Uses the center of the legend as the anchor point
                y: 1.1, // Positions the legend above the chart
                yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
            }
        };

        var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

        Plotly.react(selector, data, layout, config);
    });
}

function scatterpolarPlot(selector, mode) {
    document.addEventListener('redrawPlots', (e) => {

        if (fullData === null) {
            return;
        }

        if (!(filterA in filters)) {
            console.error('Unknown filterA:', filterA);
            return;
        }

        if (!(filterB in filters)) {
            console.error('Unknown filterB:', filterA);
            return;
        }

        const dataA = filters[filterA].values;
        const dataB = filters[filterB].values;

        const theta = ['q_age',
                       'q_play_strategy_games',
                       'q_playing_effort',
                       'q_playing_effort',
                       'q_multiple_channels_esential',
                       'q_realistic_work',
                       'q_budget_effort',
                       'q_office_effort',
                       'q_morale_complexity',
                       'q_relationships_effort'];


        const translatedTheta = theta.map(T);

        function values(data, column) {
            return data.map(row => row[column]);
        }

        function fullValues(column) {
            return fullData.map(row => row[column]);
        }

        function dimensionMedian(data, column) {
            // r should containt median for each column from theta
            const r = [];

            for (let i = 0; i < theta.length; i++) {
                var thetaValues = values(data, theta[i]);

                // we should nor to the maximum from all data, not from current data
                const max = Math.max(...fullValues(theta[i]));

                thetaValues = thetaValues.map(x => x / max);
                thetaValues.sort((a, b) => a - b);
                r.push(thetaValues[Math.floor(thetaValues.length / 2)]);
            }

            return {
              type: 'scatterpolar',
              r: r,
              theta: translatedTheta,
              fill: 'toself',
              name: column
            };
        }

        function dimensionAverage(data, column) {
            // r should containt average for each column from theta
            const r = [];

            for (let i = 0; i < theta.length; i++) {
              var thetaValues = values(data, theta[i]);

              // we should nor to the maximum from all data, not from current data
              const max = Math.max(...fullValues(theta[i]));

              thetaValues = thetaValues.map(x => x / max);
              r.push(thetaValues.reduce((a, b) => a + b, 0) / thetaValues.length);
            }

            return {
              type: 'scatterpolar',
              r: r,
              theta: translatedTheta,
              fill: 'toself',
              name: column
            };
        }

        var dimension = null;

        if (mode === 'median') {
            dimension = dimensionMedian;
        } else {
            dimension = dimensionAverage;
        }

        var data = [
            dimension(dataA, filters[filterA].name),
            dimension(dataB, filters[filterB].name)
        ];

        var layout = {
            barmode: 'group',
            xaxis: {
                dtick: 1
            },
            yaxis: {
                dtick: 1
            },
            legend: {
                orientation: 'h',
                x: 0.5, // Centers the legend horizontally
                xanchor: 'center', // Uses the center of the legend as the anchor point
                y: 1.1, // Positions the legend above the chart
                yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
            }
        };

        var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

        Plotly.react(selector, data, layout, config);
    });

}


function heatmapPlot(selector, kind) {
    document.addEventListener('redrawPlots', (e) => {

        if (fullData === null) {
            return;
        }

        if (!(filterA in filters)) {
            console.error('Unknown filterA:', filterA);
            return;
        }

        const dataA = filters[filterA].values;

        xDimension = heatmapFilterA;
        yDimension = heatmapFilterB;

        const questions = heatmapQuestions;

        const z = [];

        for (let i in questions[yDimension].values) {
            z.push([]);

            for (let j in questions[xDimension].values) {
                z[z.length-1].push(0);
            }
        }

        function extractIndexes(question, row) {
            const indexes = []

            q = questions[question]
            if (q.type == 'multichoice') {
                for (let i in q.values) {
                    const variant = q.values[i];

                    if (row[`${question}#${variant}`] == 1) {
                        indexes.push(i);
                    }
                }
            }

            if (q.type == 'numeric') {
                indexes.push(row[question] - 1);
            }

            if (q.type == 'category') {
                for (let i in q.values) {
                    const variant = q.values[i];

                    if (row[question] == variant) {
                        indexes.push(i);
                    }
                }
            }

            if (q.type == 'age') {
                for (let i in ageGroups) {
                    const group = ageGroups[i];

                    if (group.predicate(row)) {
                        indexes.push(i);
                    }
                }
            }

          if (indexes.length == 0) {
            /* it is ok for some data */
              /* console.log('something goes wrong'); */
            }

            return indexes;
        }

        const columnSizes = {};

        dataA.forEach(function(row){
            const xIndexs = extractIndexes(xDimension, row);
            const yIndexs = extractIndexes(yDimension, row);

            for (let x of xIndexs) {
                if (!(x in columnSizes)) {
                    columnSizes[x] = 0;
                }

                columnSizes[x] += 1;


                for (let y of yIndexs) {
                    z[y][x] += 1
                }
            }
        });

        const minAllowedColumnSize = 10;

        const normZ = [];

        // norm z on column sizes
        for (let i in questions[yDimension].values) {
            const row = [];
            normZ.push(row);

            for (let j in questions[xDimension].values) {

                if (xDimension == yDimension && i == j) {
                    row.push(0);
                }

                else if (columnSizes[j] != null && columnSizes[j] >= minAllowedColumnSize ) {
                    row.push(z[i][j] / columnSizes[j]);
                }
                else {
                    row.push(null);
                }
            }
        }

        const text = [];

        for ( var i = 0; i < questions[yDimension].values.length; i++ ) {
            text.push([]);
            for ( var j = 0; j < questions[xDimension].values.length; j++ ) {
                text[i].push(`${(normZ[i][j]*100).toFixed(2)}% ${T("count")}: ${z[i][j]} / ${columnSizes[j]}`);
            }
        }

        var zData = null;

        if (kind === 'norm') {
            zData = normZ;
        } else {
            zData = z;
        }


        var data = [
            {
                z: zData,
                x: questions[xDimension].values.map(T),
                y: questions[yDimension].values.map(T),
                text: text,
                type: 'heatmap'
            }
        ];

        var layout = {
            barmode: 'group',
            plot_bgcolor: "black",
            xaxis: {
                dtick: 1,
                title: T(xDimension)
            },
            yaxis: {
                dtick: 1,
                title: T(yDimension)
            }
        };

        var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

        Plotly.react(selector, data, layout, config);
    });
}


</script>
