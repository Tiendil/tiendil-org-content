<!-- TODO: move to brigid config? -->
<!-- TODO: if moved, how to turn on optionally? -->

<script src="https://cdn.plot.ly/plotly-2.29.1.min.js" charset="utf-8"></script>


<script type="text/javascript">

const redrawPlots = new CustomEvent('redrawPlots', {
    detail: {
        message: "redraw plots",
    }
 });


const audience = [
    {fraction: 0.8, minNews: 1, maxNews: 99},
    {fraction: 0.16, minNews: 100, maxNews: 999}
    {fraction: 0.04, minNews: 1000, maxNews: 1000}
];

const marginLevels = [
    {id: 'x2', name: 'x2', value: 2},
    {id: 'x3', name: 'x3', value: 3},
    {id: 'x5', name: 'x5', value: 5},
    {id: 'x10', name: 'x10', value: 10},
    {id: 'x20', name: 'x20', value: 20},
    {id: 'x50', name: 'x50', value: 50},
]

var filterASubMargin = 'x2';
var filterATokenMargin = 'x10';
var filterBSubMargin = 'x10';
var filterBTokenMargin = 'x2';

const subscribersNumber = 1000;
const daysInMonth = 30;
const COGSPerNews = 0.0007145;
const serverCost = 75;
const CAC = 50;
const CR = 0.05;
const baseSubscriptionQuota = 250;
const profSubscriptionQuota = 1000;

const paymentProcessorCommissionPercent = 0.025; // Stripe fee
const paymentProcessorCommissionFixed = 0.25;  // Stripe fee

function consumptionPrice(tokens, subQuota, subTokenPrice, extraTokenPrice) {
    const subPrice = subQuota * subTokenPrice;

    if (tokens <= subQuota) {
        return subPrice;
    }

    return subPrice + (tokens - subQuota) * extraTokenPrice;
}

function baseSubTokenPrice() {
    return "?";
}

function baseExtraTokenPrice() {
    return "?";
}

function profSubTokenPrice() {
    return "?";
}

function profExtraTokenPrice() {
    return "?";
}

function basePrice(tokens) {
    return consumptionPrice(tokens,
                            baseSubscriptionQuota,
                            baseSubTokenPrice(),
                            baseExtraTokenPrice());
}

function profPrice(tokens) {
    return consumptionPrice(tokens,
                            profSubscriptionQuota,
                            profSubTokenPrice(),
                            profExtraTokenPrice());
}

const users = [];

for (let i = 0; i < audience.length; i++) {
    const group = audience[i];
    const groupSize = Math.ceil(subscribersNumber * group.fraction);

    const {min, max} = {min: group.minNews, max: group.maxNews};

    for (let j = 0; j < groupSize; j++) {
        // deterministic quantile in (0, 1)
        const v = (j + 0.5) / groupSize;

        // log-uniform quantile: n = min * (max/min)^v
        const n = (min === max)
            ? min
              : Math.round(min * Math.pow(max / min, v));

        const newsPerDay = Math.max(min, Math.min(max, n));

        users.push({
            newsPerDay: newsPerDay,
            paid: Math.min(
                basePrice(newsPerDay * daysInMonth),
                profPrice(newsPerDay * daysInMonth)
            )
        });
    }
}


function COGSGlobal() {
    return serverCost + (Math.ceil(subscribersNumber * CR) * CAC);
}

function PaymentProcessorFee(amount) {
    return amount * paymentProcessorCommissionPercent + paymentProcessorCommissionFixed * subscribersNumber;
}

function modelQuotaSteps(modelName, subMarginX, tokenMarginX, extraTokensPurchased) {

    const groups = [];

    for (let i = 0; i < audience.length; i++) {
        const users = audience[i];

        const subTokenMargin = COGSPerNews * subMarginX;
        const subTokenPrice = COGSPerNews + subTokenMargin;

        const extraTokenMargin = COGSPerNews * tokenMarginX;
        const extraTokenPrice = COGSPerNews + extraTokenMargin;

        const newsPerMonth = users.newsPerDay * daysInMonth;

        const qoutaLevel = Math.ceil(newsPerMonth / quotaStep);
        const purchasedSubTokens = qoutaLevel * quotaStep;

        const subMonthPrice = purchasedSubTokens * subTokenPrice;
        const subMonthSpending = purchasedSubTokens * COGSPerNews;
        const subMonthMargin = subMonthPrice - subMonthSpending;

        const extraMonthPrice = extraTokensPurchased * extraTokenPrice;
        const extraMonthSpending = extraTokensPurchased * COGSPerNews;
        const extraMonthMargin = extraMonthPrice - extraMonthSpending;

        const subGrossMargin = subMonthMargin * users.fraction * subscribersNumber;
        const extraGrossMargin = extraMonthMargin * users.fraction * subscribersNumber;
        const totalGrossMargin = subGrossMargin + extraGrossMargin;

        const totalPaid = subMonthPrice + extraMonthPrice;

        groups.push({
            subStepPrice: quotaStep * subTokenPrice,
            subPrice: subMonthPrice,
            tokensPrice: extraMonthPrice,

            subMargin: subMonthMargin,
            tokenMargin: extraMonthMargin,
            grossMargin: totalGrossMargin,

            totalPaid: totalPaid
        });
    }

    const totalPaid = groups.reduce((a, b) => a + b.totalPaid, 0);
    const paymentProcessorFee = PaymentProcessorFee(totalPaid);

    return {
        model: modelName,

        subscribersNumber: subscribersNumber,
        subMarginX: subMarginX,
        tokenMarginX: tokenMarginX,

        grossMargin: groups.reduce((a, b) => a + b.grossMargin, 0) - COGSGlobal() - paymentProcessorFee,
        subMargin: groups.reduce((a, b) => a + b.subMargin, 0),
        tokenMargin: groups.reduce((a, b) => a + b.tokenMargin, 0),

        totalPaid: totalPaid,
        paymentProcessorFee: paymentProcessorFee,

        groups: groups
    };

}

function modelQuotaStepsNoTokens(subMarginX, tokenMarginX) {
    return modelQuotaSteps("quota_no_tokens", subMarginX, tokenMarginX, 0);
}

function modelQuotaStepsHasTokens(subMarginX, tokenMarginX) {
    return modelQuotaSteps("quota_with_tokens", subMarginX, tokenMarginX, quotaStep * 0.5);
}


function modelBaseSub(subMarginX, tokenMarginX) {

    const groups = [];

    for (let i = 0; i < audience.length; i++) {
        const users = audience[i];

        const subTokenMargin = COGSPerNews * subMarginX;
        const subTokenPrice = COGSPerNews + subTokenMargin;

        const extraTokenMargin = COGSPerNews * tokenMarginX;
        const extraTokenPrice = COGSPerNews + extraTokenMargin;

        const newsPerMonth = users.newsPerDay * daysInMonth;

        const extraTokensPurchased = newsPerMonth - baseSubscriptionTokens;

        const subMonthPrice = baseSubscriptionTokens * subTokenPrice
        const subMonthSpending = baseSubscriptionTokens * COGSPerNews;
        const subMonthMargin = subMonthPrice - subMonthSpending;

        const extraMonthPrice = extraTokensPurchased * extraTokenPrice;
        const extraMonthSpending = extraTokensPurchased * COGSPerNews;
        const extraMonthMargin = extraMonthPrice - extraMonthSpending;

        const subGrossMargin = subMonthMargin * users.fraction * subscribersNumber;
        const extraGrossMargin = extraMonthMargin * users.fraction * subscribersNumber;
        const totalGrossMargin = subGrossMargin + extraGrossMargin;

        const totalPaid = subMonthPrice + extraMonthPrice;

        groups.push({
            subStepPrice: quotaStep * subTokenPrice,
            subPrice: subMonthPrice,
            tokensPrice: extraMonthPrice,

            subMargin: subMonthMargin,
            tokenMargin: extraMonthMargin,
            grossMargin: totalGrossMargin,

            totalPaid: totalPaid
        });
    }

    const totalPaid = groups.reduce((a, b) => a + b.totalPaid, 0);
    const paymentProcessorFee = PaymentProcessorFee(totalPaid);

    return {
        model: "base_sub",

        subscribersNumber: subscribersNumber,
        subMarginX: subMarginX,
        tokenMarginX: tokenMarginX,

        grossMargin: groups.reduce((a, b) => a + b.grossMargin, 0) - COGSGlobal() - paymentProcessorFee,
        subMargin: groups.reduce((a, b) => a + b.subMargin, 0),
        tokenMargin: groups.reduce((a, b) => a + b.tokenMargin, 0),

        totalPaid: totalPaid,
        paymentProcessorFee: paymentProcessorFee,

        groups: groups
    };

}

var fullData = [];

for (subMarginLevel of marginLevels) {
    for (tokenMarginLevel of marginLevels) {
        fullData.push(modelQuotaStepsNoTokens(subMarginLevel.value,
                                              tokenMarginLevel.value));
        fullData.push(modelQuotaStepsHasTokens(subMarginLevel.value,
                                               tokenMarginLevel.value));
        fullData.push(modelBaseSub(subMarginLevel.value,
                                   tokenMarginLevel.value));
    }
}

console.log('fullData', fullData);

function createPlotlyConfig(filename) {
    var config = {
        toImageButtonOptions: {
            format: 'png', // one of png, svg, jpeg, webp
            filename: filename,
            scale: 1
        },
        modeBarButtonsToRemove: [
            'zoom2d', 'pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d',
            'zoom3d', 'pan3d', 'orbitRotation', 'tableRotation', 'handleDrag3d',
            'resetCameraDefault3d', 'resetCameraLastSave3d', 'hoverClosest3d',
            'hoverClosestCartesian', 'hoverCompareCartesian',
            'zoomInGeo', 'zoomOutGeo', 'resetGeo', 'hoverClosestGeo',
            'hoverClosestGl2d', 'hoverClosestPie', 'toggleHover', 'resetViews', 'sendDataToCloud', 'toggleSpikelines', 'resetViewMapbox'
        ]
    }
}

function filterRows(subMarginId, tokenMarginId) {
    const subMarginValue = marginLevels.find(level => level.id === subMarginId).value;
    const tokenMarginValue = marginLevels.find(level => level.id === tokenMarginId).value;

    return fullData.filter(function(row) {
        return row.subMarginX === subMarginValue &&
               row.tokenMarginX === tokenMarginValue;
    });
}

function barPlot(selector, map, barsOrder) {

    document.addEventListener('redrawPlots', (e) => {

        // if (!(filterA in filters)) {
        //     console.log('Unknown filterA:', filterA);
        //     return;
        // }

        // if (!(filterB in filters)) {
        //     console.log('Unknown filterB:', filterA);
        //     return;
        // }

        // const dataA = getPlotData(filters[filterA].values, map, barsOrder);
        // const dataB = getPlotData(filters[filterB].values, map, barsOrder);

        const dataARows = filterRows(filterASubMargin, filterATokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);
        const dataBRows = filterRows(filterBSubMargin, filterBTokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);

        // function toText(percents, counts) {
        //     return percents.map((x, i) => x.toString() + ' ' + T('% count:') + ' ' + counts[i].toString());
        // }

        function barData(name, dataRows) {
            return {
                x: dataRows.map(row => `${row.model}`),
                y: dataRows.map(row => row.grossMargin.toFixed(2)),
                text: dataRows.map(row => row.grossMargin.toFixed(2)),
                'textposition': "none",
                'hoverinfo': 'text',
                'name': name,
                'type': 'bar'
            };
        }

        var data = [
            barData("approach 1", dataARows),
            barData("approach 2", dataBRows)
        ];

        var layout = {
            barmode: 'group',
            xaxis: {
                dtick: 1
            },
            yaxis: {
                title: 'Gross Margin, $',
            },
            legend: {
                orientation: 'h',
                x: 0.5, // Centers the legend horizontally
                xanchor: 'center', // Uses the center of the legend as the anchor point
                y: 1.1, // Positions the legend above the chart
                yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
            }
        };

        // TODO: better unique name
        var config = createPlotlyConfig('${filterASubMargin}-${filterATokenMargin}-${filterBSubMargin}-${filterBTokenMargin}');

        Plotly.react(selector, data, layout, config);
    });
}

// function scatterpolarPlot(selector, mode) {
//     document.addEventListener('redrawPlots', (e) => {

//         if (fullData === null) {
//             return;
//         }

//         if (!(filterA in filters)) {
//             console.error('Unknown filterA:', filterA);
//             return;
//         }

//         if (!(filterB in filters)) {
//             console.error('Unknown filterB:', filterA);
//             return;
//         }

//         const dataA = filters[filterA].values;
//         const dataB = filters[filterB].values;

//         const theta = ['q_age',
//                        'q_play_strategy_games',
//                        'q_playing_effort',
//                        'q_playing_effort',
//                        'q_multiple_channels_esential',
//                        'q_realistic_work',
//                        'q_budget_effort',
//                        'q_office_effort',
//                        'q_morale_complexity',
//                        'q_relationships_effort'];


//         const translatedTheta = theta.map(T);

//         function values(data, column) {
//             return data.map(row => row[column]);
//         }

//         function fullValues(column) {
//             return fullData.map(row => row[column]);
//         }

//         function dimensionMedian(data, column) {
//             // r should containt median for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//                 var thetaValues = values(data, theta[i]);

//                 // we should nor to the maximum from all data, not from current data
//                 const max = Math.max(...fullValues(theta[i]));

//                 thetaValues = thetaValues.map(x => x / max);
//                 thetaValues.sort((a, b) => a - b);
//                 r.push(thetaValues[Math.floor(thetaValues.length / 2)]);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         function dimensionAverage(data, column) {
//             // r should containt average for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//               var thetaValues = values(data, theta[i]);

//               // we should nor to the maximum from all data, not from current data
//               const max = Math.max(...fullValues(theta[i]));

//               thetaValues = thetaValues.map(x => x / max);
//               r.push(thetaValues.reduce((a, b) => a + b, 0) / thetaValues.length);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         var dimension = null;

//         if (mode === 'median') {
//             dimension = dimensionMedian;
//         } else {
//             dimension = dimensionAverage;
//         }

//         var data = [
//             dimension(dataA, filters[filterA].name),
//             dimension(dataB, filters[filterB].name)
//         ];

//         var layout = {
//             barmode: 'group',
//             xaxis: {
//                 dtick: 1
//             },
//             yaxis: {
//                 dtick: 1
//             },
//             legend: {
//                 orientation: 'h',
//                 x: 0.5, // Centers the legend horizontally
//                 xanchor: 'center', // Uses the center of the legend as the anchor point
//                 y: 1.1, // Positions the legend above the chart
//                 yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
//             }
//         };

//         var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

//         Plotly.react(selector, data, layout, config);
//     });

// }


// function heatmapPlot(selector, kind) {
//     document.addEventListener('redrawPlots', (e) => {

//         if (fullData === null) {
//             return;
//         }

//         if (!(filterA in filters)) {
//             console.error('Unknown filterA:', filterA);
//             return;
//         }

//         const dataA = filters[filterA].values;

//         xDimension = heatmapFilterA;
//         yDimension = heatmapFilterB;

//         const questions = heatmapQuestions;

//         const z = [];

//         for (let i in questions[yDimension].values) {
//             z.push([]);

//             for (let j in questions[xDimension].values) {
//                 z[z.length-1].push(0);
//             }
//         }

//         function extractIndexes(question, row) {
//             const indexes = []

//             q = questions[question]
//             if (q.type == 'multichoice') {
//                 for (let i in q.values) {
//                     const variant = q.values[i];

//                     if (row[`${question}#${variant}`] == 1) {
//                         indexes.push(i);
//                     }
//                 }
//             }

//             if (q.type == 'numeric') {
//                 indexes.push(row[question] - 1);
//             }

//             if (q.type == 'category') {
//                 for (let i in q.values) {
//                     const variant = q.values[i];

//                     if (row[question] == variant) {
//                         indexes.push(i);
//                     }
//                 }
//             }

//             if (q.type == 'age') {
//                 for (let i in ageGroups) {
//                     const group = ageGroups[i];

//                     if (group.predicate(row)) {
//                         indexes.push(i);
//                     }
//                 }
//             }

//           if (indexes.length == 0) {
//             /* it is ok for some data */
//               /* console.log('something goes wrong'); */
//             }

//             return indexes;
//         }

//         const columnSizes = {};

//         dataA.forEach(function(row){
//             const xIndexs = extractIndexes(xDimension, row);
//             const yIndexs = extractIndexes(yDimension, row);

//             for (let x of xIndexs) {
//                 if (!(x in columnSizes)) {
//                     columnSizes[x] = 0;
//                 }

//                 columnSizes[x] += 1;


//                 for (let y of yIndexs) {
//                     z[y][x] += 1
//                 }
//             }
//         });

//         const minAllowedColumnSize = 10;

//         const normZ = [];

//         // norm z on column sizes
//         for (let i in questions[yDimension].values) {
//             const row = [];
//             normZ.push(row);

//             for (let j in questions[xDimension].values) {

//                 if (xDimension == yDimension && i == j) {
//                     row.push(0);
//                 }

//                 else if (columnSizes[j] != null && columnSizes[j] >= minAllowedColumnSize ) {
//                     row.push(z[i][j] / columnSizes[j]);
//                 }
//                 else {
//                     row.push(null);
//                 }
//             }
//         }

//         const text = [];

//         for ( var i = 0; i < questions[yDimension].values.length; i++ ) {
//             text.push([]);
//             for ( var j = 0; j < questions[xDimension].values.length; j++ ) {
//                 text[i].push(`${(normZ[i][j]*100).toFixed(2)}% ${T("count")}: ${z[i][j]} / ${columnSizes[j]}`);
//             }
//         }

//         var zData = null;

//         if (kind === 'norm') {
//             zData = normZ;
//         } else {
//             zData = z;
//         }


//         var data = [
//             {
//                 z: zData,
//                 x: questions[xDimension].values.map(T),
//                 y: questions[yDimension].values.map(T),
//                 text: text,
//                 type: 'heatmap'
//             }
//         ];

//         var layout = {
//             barmode: 'group',
//             plot_bgcolor: "black",
//             xaxis: {
//                 dtick: 1,
//                 title: T(xDimension)
//             },
//             yaxis: {
//                 dtick: 1,
//                 title: T(yDimension)
//             }
//         };

//         var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

//         Plotly.react(selector, data, layout, config);
//     });
// }


</script>
