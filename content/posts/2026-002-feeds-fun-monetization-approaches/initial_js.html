<!-- TODO: move to brigid config? -->
<!-- TODO: if moved, how to turn on optionally? -->

<script src="https://cdn.plot.ly/plotly-2.29.1.min.js" charset="utf-8"></script>


<script type="text/javascript">

const redrawPlots = new CustomEvent('redrawPlots', {
    detail: {
        message: "redraw plots",
    }
 });


const audience = [
    {fraction: 0.8, minNews: 1, maxNews: 99},
    {fraction: 0.16, minNews: 100, maxNews: 999},
    {fraction: 0.04, minNews: 1000, maxNews: 1000}
];

const marginLevels = [
    {id: 'x2', name: 'x2', value: 2},
    {id: 'x3', name: 'x3', value: 3},
    {id: 'x5', name: 'x5', value: 5},
    {id: 'x10', name: 'x10', value: 10},
    {id: 'x20', name: 'x20', value: 20},
    // {id: 'x50', name: 'x50', value: 50},  // commented temporary, do not taught
];

const discountLevels = [
    {id: 'd05', name: '5%', value: 0.05},
    {id: 'd10', name: '10%', value: 0.10},
    {id: 'd15', name: '15%', value: 0.15},
    // {id: 'd20', name: '20%', value: 0.20},  // commented temporary, do not taught
];

var filterASubMargin = 'x2';
var filterATokenMargin = 'x10';
var filterBSubMargin = 'x10';
var filterBTokenMargin = 'x2';

const subscribersNumber = 1000;
const daysInMonth = 30;
const COGSPerNews = 0.0006865;
const serverCost = 75;
const CAC = 50;
const CR = 0.05;
const baseSubscriptionQuota = 250;
const profSubscriptionQuota = 1000;
const discountStep = 0.1;

const paymentProcessorCommissionPercent = 0.025; // Stripe fee
const paymentProcessorCommissionFixed = 0.25;  // Stripe fee

function consumptionPrice(tokens, subQuota, subTokenPrice, extraTokenPrice) {
    const subPrice = subQuota * subTokenPrice;

    if (tokens <= subQuota) {
        return subPrice;
    }

    return subPrice + (tokens - subQuota) * extraTokenPrice;
}
function baseSubTokenPrice(N) {
    return COGSPerNews * N;
}

function baseExtraTokenPrice(N, step) {
    return COGSPerNews * N * (1 - 1 * step);
}

function profSubTokenPrice(N, step) {
    return COGSPerNews * N * (1 - 2 * step);
}

function profExtraTokenPrice(N, step) {
    return COGSPerNews * N * (1 - 3 * step);
}

function basePricePerDay(tokens, N, step) {
    return consumptionPrice(tokens,
                            baseSubscriptionQuota,
                            baseSubTokenPrice(N),
                            baseExtraTokenPrice(N, step));
}

function profPricePerDay(tokens, N, step) {
    return consumptionPrice(tokens,
                            profSubscriptionQuota,
                            profSubTokenPrice(N, step),
                            profExtraTokenPrice(N, step));
}

function paidInMonth(tokensPerDay, N, step) {
    const paidInDay = Math.min(basePricePerDay(tokensPerDay, N, step),
                               profPricePerDay(tokensPerDay, N, step));
    return paidInDay * daysInMonth;
}

function spentInMonth(tokensPerDay) {
    return tokensPerDay * COGSPerNews * daysInMonth;
}

const users = [];

for (let i = 0; i < audience.length; i++) {
    const group = audience[i];
    const groupSize = Math.ceil(subscribersNumber * group.fraction);

    const {min, max} = {min: group.minNews, max: group.maxNews};

    for (let j = 0; j < groupSize; j++) {
        // deterministic quantile in (0, 1)
        const v = (j + 0.5) / groupSize;

        // log-uniform quantile: n = min * (max/min)^v
        const n = (min === max)
            ? min
              : Math.round(min * Math.pow(max / min, v));

        const newsPerDay = Math.max(min, Math.min(max, n));

        users.push({
            newsPerDay: newsPerDay,
        });
    }
}

function COGSGlobal() {
    return serverCost + (Math.ceil(subscribersNumber * CR) * CAC);
}

function PaymentProcessorFee(amount) {
    return amount * paymentProcessorCommissionPercent + paymentProcessorCommissionFixed * subscribersNumber;
}

function model(costMultipler, discountStep) {

    let paidTotal = 0;
    let spentTotal = 0;

    for (let i = 0; i < users.length; i++) {
        const user = users[i];

        const paid = paidInMonth(user.newsPerDay,
                                 costMultipler,
                                 discountStep);

        const spent = spentInMonth(user.newsPerDay);

        paidTotal += paid;
        spentTotal += spent;
    }

    const paymentProcessorFee = PaymentProcessorFee(paidTotal);

    return {
        costMultipler: costMultipler,
        discountStep: discountStep,
        totalPaid: paidTotal,

        spentOnNews: spentTotal,
        paymentProcessorFee: paymentProcessorFee,

        grossMargin: paidTotal - spentTotal - COGSGlobal() - paymentProcessorFee
    };

}

const fullData = [];

for (let subMarginLevel of marginLevels) {
    for (let discountLevel of discountLevels) {
        fullData.push(model(subMarginLevel.value, discountLevel.value));
    }
}

console.log('fullData', fullData);

function createPlotlyConfig(filename) {
    var config = {
        toImageButtonOptions: {
            format: 'png', // one of png, svg, jpeg, webp
            filename: filename,
            scale: 1
        },
        modeBarButtonsToRemove: [
            'zoom2d', 'pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d',
            'zoom3d', 'pan3d', 'orbitRotation', 'tableRotation', 'handleDrag3d',
            'resetCameraDefault3d', 'resetCameraLastSave3d', 'hoverClosest3d',
            'hoverClosestCartesian', 'hoverCompareCartesian',
            'zoomInGeo', 'zoomOutGeo', 'resetGeo', 'hoverClosestGeo',
            'hoverClosestGl2d', 'hoverClosestPie', 'toggleHover', 'resetViews', 'sendDataToCloud', 'toggleSpikelines', 'resetViewMapbox'
        ]
    };

    return config;
}

function heatmapPlot(selector, kind) {
    document.addEventListener('redrawPlots', (e) => {

        if (fullData === null) {
            return;
        }

        const metric = kind || 'grossMargin';
        const metricLabels = {
            grossMargin: 'Gross Margin, $',
            totalPaid: 'Total Paid, $',
            spentOnNews: 'Spent on News, $',
            paymentProcessorFee: 'Payment Processor Fee, $'
        };

        const dataByKey = new Map();

        function keyFor(marginValue, discountValue) {
            return `${marginValue}|${discountValue.toFixed(4)}`;
        }

        for (let row of fullData) {
            dataByKey.set(keyFor(row.costMultipler, row.discountStep), row);
        }

        function formatMoney(value) {
            if (value == null || Number.isNaN(value)) {
                return 'N/A';
            }
            return (value / 1000).toFixed(2) + 'k';
        }

        const z = [];
        const text = [];

        for (let discount of discountLevels) {
            const row = [];
            const textRow = [];

            for (let margin of marginLevels) {
                const rowData = dataByKey.get(keyFor(margin.value, discount.value));
                const metricValue = rowData ? rowData[metric] : null;

                row.push(metricValue);
                textRow.push(
                    rowData
                        ? `Gross Margin: ${formatMoney(rowData.grossMargin)}<br>` +
                          `Total Paid: ${formatMoney(rowData.totalPaid)}<br>` +
                          `Spent on News: ${formatMoney(rowData.spentOnNews)}<br>` +
                          `Payment Fees: ${formatMoney(rowData.paymentProcessorFee)}`
                        : 'N/A'
                );
            }

            z.push(row);
            text.push(textRow);
        }

        var data = [
            {
                z: z,
                x: marginLevels.map(level => level.name),
                y: discountLevels.map(level => level.name),
                text: text,
                type: 'heatmap',
                hoverinfo: 'text',
                colorbar: {
                    title: metricLabels[metric] || metric
                }
            }
        ];

        var layout = {
            barmode: 'group',
            xaxis: {
                title: 'Margin multiplier'
            },
            yaxis: {
                title: 'Discount'
            }
        };

        var config = createPlotlyConfig(`${selector}-${metric}`);

        Plotly.react(selector, data, layout, config);
    });
}

// function filterRows(subMarginId, tokenMarginId) {
//     const subMarginValue = marginLevels.find(level => level.id === subMarginId).value;
//     const tokenMarginValue = marginLevels.find(level => level.id === tokenMarginId).value;

//     return fullData.filter(function(row) {
//         return row.subMarginX === subMarginValue &&
//                row.tokenMarginX === tokenMarginValue;
//     });
// }

// function barPlot(selector, map, barsOrder) {

//     document.addEventListener('redrawPlots', (e) => {

//         const dataARows = filterRows(filterASubMargin, filterATokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);
//         const dataBRows = filterRows(filterBSubMargin, filterBTokenMargin).sort((a, b) => a.subscribersNumber - b.subscribersNumber);

//         // function toText(percents, counts) {
//         //     return percents.map((x, i) => x.toString() + ' ' + T('% count:') + ' ' + counts[i].toString());
//         // }

//         function barData(name, dataRows) {
//             return {
//                 x: dataRows.map(row => `${row.model}`),
//                 y: dataRows.map(row => row.grossMargin.toFixed(2)),
//                 text: dataRows.map(row => row.grossMargin.toFixed(2)),
//                 'textposition': "none",
//                 'hoverinfo': 'text',
//                 'name': name,
//                 'type': 'bar'
//             };
//         }

//         var data = [
//             barData("approach 1", dataARows),
//             barData("approach 2", dataBRows)
//         ];

//         var layout = {
//             barmode: 'group',
//             xaxis: {
//                 dtick: 1
//             },
//             yaxis: {
//                 title: 'Gross Margin, $',
//             },
//             legend: {
//                 orientation: 'h',
//                 x: 0.5, // Centers the legend horizontally
//                 xanchor: 'center', // Uses the center of the legend as the anchor point
//                 y: 1.1, // Positions the legend above the chart
//                 yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
//             }
//         };

//         // TODO: better unique name
//         var config = createPlotlyConfig('${filterASubMargin}-${filterATokenMargin}-${filterBSubMargin}-${filterBTokenMargin}');

//         Plotly.react(selector, data, layout, config);
//     });
// }

// function scatterpolarPlot(selector, mode) {
//     document.addEventListener('redrawPlots', (e) => {

//         if (fullData === null) {
//             return;
//         }

//         if (!(filterA in filters)) {
//             console.error('Unknown filterA:', filterA);
//             return;
//         }

//         if (!(filterB in filters)) {
//             console.error('Unknown filterB:', filterA);
//             return;
//         }

//         const dataA = filters[filterA].values;
//         const dataB = filters[filterB].values;

//         const theta = ['q_age',
//                        'q_play_strategy_games',
//                        'q_playing_effort',
//                        'q_playing_effort',
//                        'q_multiple_channels_esential',
//                        'q_realistic_work',
//                        'q_budget_effort',
//                        'q_office_effort',
//                        'q_morale_complexity',
//                        'q_relationships_effort'];


//         const translatedTheta = theta.map(T);

//         function values(data, column) {
//             return data.map(row => row[column]);
//         }

//         function fullValues(column) {
//             return fullData.map(row => row[column]);
//         }

//         function dimensionMedian(data, column) {
//             // r should containt median for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//                 var thetaValues = values(data, theta[i]);

//                 // we should nor to the maximum from all data, not from current data
//                 const max = Math.max(...fullValues(theta[i]));

//                 thetaValues = thetaValues.map(x => x / max);
//                 thetaValues.sort((a, b) => a - b);
//                 r.push(thetaValues[Math.floor(thetaValues.length / 2)]);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         function dimensionAverage(data, column) {
//             // r should containt average for each column from theta
//             const r = [];

//             for (let i = 0; i < theta.length; i++) {
//               var thetaValues = values(data, theta[i]);

//               // we should nor to the maximum from all data, not from current data
//               const max = Math.max(...fullValues(theta[i]));

//               thetaValues = thetaValues.map(x => x / max);
//               r.push(thetaValues.reduce((a, b) => a + b, 0) / thetaValues.length);
//             }

//             return {
//               type: 'scatterpolar',
//               r: r,
//               theta: translatedTheta,
//               fill: 'toself',
//               name: column
//             };
//         }

//         var dimension = null;

//         if (mode === 'median') {
//             dimension = dimensionMedian;
//         } else {
//             dimension = dimensionAverage;
//         }

//         var data = [
//             dimension(dataA, filters[filterA].name),
//             dimension(dataB, filters[filterB].name)
//         ];

//         var layout = {
//             barmode: 'group',
//             xaxis: {
//                 dtick: 1
//             },
//             yaxis: {
//                 dtick: 1
//             },
//             legend: {
//                 orientation: 'h',
//                 x: 0.5, // Centers the legend horizontally
//                 xanchor: 'center', // Uses the center of the legend as the anchor point
//                 y: 1.1, // Positions the legend above the chart
//                 yanchor: 'bottom' // Uses the bottom of the legend to position it relative to the chart
//             }
//         };

//         var config = createPlotlyConfig('${selector}-${filterA}-${filterB}');

//         Plotly.react(selector, data, layout, config);
//     });

// }



</script>
